# Lottery Contract

function drawFinalNumberAndMakeLotteryClaimable(uint256 \_lotteryId, bool \_autoInjection)

require(\_lotteries\[\_lotteryId].status == Status.Close, "Lottery not close");

require(\_lotteryId == randomGenerator.viewLatestLotteryId(), "Numbers not drawn");

// Calculate the finalNumber based on the randomResult generated by ChainLink's fallback

uint32 finalNumber = randomGenerator.viewRandomResult();

// Initialize a number to count addresses in the previous bracket

uint256 numberAddressesInPreviousBracket;

// Calculate the amount to share post-treasury fee

uint256 amountToShareToWinners = (

((\_lotteries\[\_lotteryId].amountCollectedInCake) \* (10000 - \_lotteries\[\_lotteryId].treasuryFee))

// Initializes the amount to withdraw to treasury

uint256 amountToWithdrawToTreasury;

// Calculate prizes in CAKE for each bracket by starting from the highest one

for (uint32 i = 0; i < 6; i++) {

uint32 transformedWinningNumber = \_bracketCalculator\[j] + (finalNumber % (uint32(10)\*\*(j + 1)));

\_lotteries\[\_lotteryId].countWinnersPerBracket\[j] =

\_numberTicketsPerLotteryId\[\_lotteryId]\[transformedWinningNumber] -

numberAddressesInPreviousBracket;

// A. If number of users for this \_bracket number is superior to 0

(\_numberTicketsPerLotteryId\[\_lotteryId]\[transformedWinningNumber] - numberAddressesInPreviousBracket) !=

// B. If rewards at this bracket are > 0, calculate, else, report the numberAddresses from previous bracket

if (\_lotteries\[\_lotteryId].rewardsBreakdown\[j] != 0) {

\_lotteries\[\_lotteryId].cakePerBracket\[j] =

((\_lotteries\[\_lotteryId].rewardsBreakdown\[j] \* amountToShareToWinners) /

(\_numberTicketsPerLotteryId\[\_lotteryId]\[transformedWinningNumber] -

numberAddressesInPreviousBracket)) /

// Update numberAddressesInPreviousBracket

numberAddressesInPreviousBracket = \_numberTicketsPerLotteryId\[\_lotteryId]\[transformedWinningNumber];

// A. No CAKE to distribute, they are added to the amount to withdraw to treasury address

\_lotteries\[\_lotteryId].cakePerBracket\[j] = 0;

amountToWithdrawToTreasury +=

(\_lotteries\[\_lotteryId].rewardsBreakdown\[j] \* amountToShareToWinners) /

// Update internal statuses for lottery

\_lotteries\[\_lotteryId].finalNumber = finalNumber;

\_lotteries\[\_lotteryId].status = Status.Claimable;

pendingInjectionNextLottery = amountToWithdrawToTreasury;

amountToWithdrawToTreasury = 0;

amountToWithdrawToTreasury += (\_lotteries\[\_lotteryId].amountCollectedInCake - amountToShareToWinners);

// Transfer CAKE to treasury address

cakeToken.safeTransfer(treasuryAddress, amountToWithdrawToTreasury);

emit LotteryNumberDrawn(currentLotteryId, finalNumber, numberAddressesInPreviousBracket);
